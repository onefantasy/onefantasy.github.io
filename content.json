{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"关于JS深拷贝的思路及函数实现","text":"什么是深拷贝在JavaScript中，复制一个变量最常见的方法如下： 12let a = 1;let b = a; 通过上面的这种方式我们可以将一个变量复制给另一个变量，并且两个变量a , b都用有自己的空间互不干扰。然而，这样的复制方式只适用于a不是引用类型的变量，若是按照上面的代码是实现引用类型的复制，如下： 1234567891011121314151617181920let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;}console.log(&apos;a的内容为：&apos;);console.log(a);let b = a;console.log(&apos;b的内容为：&apos;);console.log(b);b.name = &apos;b&apos;; //此处更改b中的nameconsole.log(&apos;更改后的结果如下：&apos;);console.log(&apos;a的内容为：&apos;);console.log(a);console.log(&apos;b的内容为：&apos;);console.log(b); 运行结果如下： 在更改之前，b中的内容完全和a的一样，因为对象是存储在堆内存中的，栈中保存的是地址值，也就是说a实际存储的是这个对象的地址，而不是这个对象内容，所以b = a实际上也只是将a存储的地址给了b，结果就是两个变量a和b实际上是指向了同一块内存空间。 所以当b.name改变的时候，实际上是改变了这块内存空间中name的值，所以在更改之后打印出来的a和b中的name都是’b’，这显然不是我想要的结果，我只是希望更改b中的name为’b’而已，因此在更改b的时候不能干扰到a，所以我需要让b指向另一块内存空间，且拥有与a相同的属性和方法。而深拷贝就是为了决解这种问题。 深拷贝实现的基本思路深拷贝的实现主要依据下面三点： 非引用类型的变量复制的时候，内存会为其分配新的空间。 非引用类型的变量，只需使用 b = a的形式进行复制 如果是引用类型的变量，将其指向的内存空间中的属性与方法拿出来，然后使用上一点的形式进行复制 实现深拷贝的函数方式一具体代码实现如下： 1234567891011function deepCopy(obj){ //如果不是引用类型的变量，直接返回 if(typeof(obj) !== &apos;object&apos;) return obj; //判断是不是数组 let newObj = toString.call(obj) === &apos;[object Array]&apos; ? [] : {}; for(let key in obj){ //因为引用类型的变量之中可以继续存在引用类型的属性，所以此处需要使用递归 newObj[key] = deepCopy(obj[key]); } return newObj;} 测试的代码如下： 12345678910111213141516171819202122232425262728let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;, say:function(){ console.log(&apos;你好&apos;); }, grade:{ Chinese: 100, math: 99, English: 98 }, hobby: [&apos;sing&apos;,&apos;jump&apos;,&apos;rap&apos;,&apos;basketball&apos;]}console.log(&apos;a的内容为：&apos;);console.log(a);let b = deepCopy(a);console.log(&apos;b的内容为：&apos;);console.log(b);b.name = &apos;b&apos;;console.log(&apos;更改后的结果如下：&apos;);console.log(&apos;a的内容为：&apos;);console.log(a);console.log(&apos;b的内容为：&apos;);console.log(b); 测试结果如下： 方式二无意中在网络上看到的另一种比较简单、粗暴的思路，就是将引用类型直接转变为字符串，字符串不是引用类型的变量，因此，可以直接使用b = a的形式进行复制，也能达到我想要的结果。具体代码如下： 12345678function deepCopy(obj){ //如果不是引用类型的变量，直接返回 if(typeof(obj) !== &apos;object&apos;) return obj; //将对象转变为字符串，再进行复制 let newObj = JSON.stringify(obj); //将字符串变回对象 return JSON.parse(newObj);} 测试代码如下： 123456789101112131415161718192021222324252627282930let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;, say:function(){ console.log(&apos;你好&apos;); }, grade:{ Chinese: 100, math: 99, English: 98 }, hobby: [&apos;sing&apos;,&apos;jump&apos;,&apos;rap&apos;,&apos;basketball&apos;] } console.log(&apos;a的内容为：&apos;); console.log(a); let b = deepCopy(a); console.log(&apos;b的内容为：&apos;); console.log(b); b.name = &apos;b&apos;; console.log(&apos;更改后的结果如下：&apos;); console.log(&apos;a的内容为：&apos;); console.log(a); console.log(&apos;b的内容为：&apos;); console.log(b); 测试结果如下：","link":"/2019/08/10/关于JS深拷贝的思路及函数实现/"},{"title":"网络上那些面试题-试题1","text":"题目请写出以下代码的输出结果。123456789101112131415161718function Foo() { Foo.a = function() { console.log(1) } this.a = function() { console.log(2) }}Foo.prototype.a = function() { console.log(3)}Foo.a = function() { console.log(4)}Foo.a();let obj = new Foo();obj.a();Foo.a(); 答案 4 2 1 分析 1 ~ 8行只是定义了一个函数，并没有执行 9 ~ 11行在这个Foo这个对象的原型上添加了一个a的函数 12 ~ 14行为Foo这个函数添加了一个自定义的方法a，故在调用a时，会在自身中找到。 15行调用了Foo.a()，实际上是调用了12 ~ 14行所添加的a方法，因为函数里定义的Foo.a因为Foo函数此时还没有执行，所以没有生效。 16行new了一个新的Foo的对象obj，同时也执行了Foo函数。因此回到2 ~ 4行，这部分代码为Foo改写了a方法，故以后Foo.a = function(){console.log(1)}；而在4 ~ 7行中，this指向调用Foo的对象obj，故obj.a = function(){console.log(2)}。 17行，此时obj.a = function(){console.log(2)} 18行，此时Foo.a已经被自身函数的代买改写了，故此时Foo.a = function(){console.log(1)}","link":"/2019/08/08/网络上那些面试题-试题1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/08/hello-world/"},{"title":"网络上那些面试题-试题2","text":"题目用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。答案个人答案： 1234567function reverseOrder(str){ str += &apos;&apos;; if(str.length &lt;= 1) return str; let str1 = reverseOrder(str.slice(0,str.length/2)); let str2 = reverseOrder(str.slice(str.length/2)); return str2+str1;} 这个答案采用的是分治的思想，将一个大问题分解成无数个相同的小问题进行求解，直到无法继续分割(即字符串只剩一个字符为止)，然后按照相反的顺序进行返回，就能得出最终结果。 关于这个问题在网络有许多解法，基本的思路都是将int型数据转成字符串，然后从第一个或最后一个字符开始，每次切割出一个字符，然后按照相反的顺序进行拼接，或者将这个int型数据去除以10求余，然后执行与字符串类似的拼接操作。","link":"/2019/08/09/网络上那些面试题-试题2/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"面试","slug":"面试","link":"/tags/面试/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web前端/"}]}