{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"JavaScrip splice()","text":"1. splice()函数的定义及作用 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 splice的注意点 该方法会改变原始数组。 所有主流浏览器都支持 splice() 方法。 2. 语法 1array.splice(start, deleteCount, ...item) 3. 参数解析 start(必需): 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。 deleteCount(可选): 整数，表示要移除的数组元素的个数。 如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。 如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。 …item: 要添加进数组的元素,从start 位置开始。 如果不指定，则 splice() 将只删除数组元素。 该参数表示可以添加多个元素。 4. 用法（1）删除 让splice()执行删除功能，有两种选择 只传递第一个参数，第一个参数为指定起始位置，该函数会将该参数指定的位置及其后面的所有内容都删除。 传递第一个参数和第二个参数，第一个参数为指定开始删除的位置，第而二个参数为指定要删除的数组的元素个数。 示例如下： 1234let arr = [0,1,2,3,4,5,6,7];//只传递一个参数arr.splice(2); //执行之后arr=[0,1]，从第2个位置开始（包括第2个位置），到数组末尾的内容都被删除 12345let arr = [0,1,2,3,4,5,6,7];//传递前两个参数arr.splice(2,2);//执行之后 arr=[0,1,4,5,6,7],从第2个位置开始（包括第2个位置在内）的两个元素被删除，即2，3被删除了 （2）替换 替换的操作需要三个参数，第三个参数为替换的内容，将n个元素替换成另外的m个元素(n为原数组中需要替换的元素的个数，m为第3个参数里元素的个数，n可以等于m)，该操作可以理解如下： 从起始位置开始（包括起始位置），删除n个元素 将第三个参数里面的m个元素从起始位置开始，依次插入 示例如下： n === m: 123let arr = [0,1,2,3,4,5,6,7];arr.splice(2,2,&apos;a&apos;,&apos;b&apos;);//执行后，arr=[0,1,&apos;a&apos;,&apos;b&apos;,4,5,6,7] 此时，从第2个位置开始（包括第2个位置在内）的两个元素被删除，即2，3被删除了，然后从第2个位置开始插入’a’,’b’两个元素。即实现了将2，3替换成’a’,’b’。 n != m 123 let arr = [0,1,2,3,4,5,6,7];arr.splice(2,2,&apos;a&apos;,&apos;b&apos;);//执行后，arr=[0,1,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,4,5,6,7] 基本操作同上，将2，3替换成’a’,’b’,’c’。 （3）插入 实现插入操作时，第二个参数必须为0，不让splice删除任何元素 然后从指定的位置开始插入m个元素（m为第三个参数里元素的数量） 示例如下： 1234 let arr = [0,1,2,3,4,5,6,7]; // 第二个参数必须为0arr.splice(2,0,&apos;a&apos;,&apos;b&apos;);//执行后，arr=[0,1,&apos;a&apos;,&apos;b&apos;,2,3,4,5,6,7] 从第2个元素开始，插入’a’,’b’两个元素。","link":"/2019/08/12/JavaScrip之splice/"},{"title":"css瀑布流布局","text":"一、html结构注意class css样式主要使用多列布局，形成多列，然后使用浮动，让形成瀑布流的子元素自动排列注意，需要为形成瀑布流的子元素设置高度，不然会被截断 三、运行结果","link":"/2019/09/13/css瀑布流布局/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/08/hello-world/"},{"title":"关于JS深拷贝的思路及函数实现","text":"什么是深拷贝在JavaScript中，复制一个变量最常见的方法如下： 12let a = 1;let b = a; 通过上面的这种方式我们可以将一个变量复制给另一个变量，并且两个变量a , b都用有自己的空间互不干扰。然而，这样的复制方式只适用于a不是引用类型的变量，若是按照上面的代码是实现引用类型的复制，如下： 1234567891011121314151617181920let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;}console.log(&apos;a的内容为：&apos;);console.log(a);let b = a;console.log(&apos;b的内容为：&apos;);console.log(b);b.name = &apos;b&apos;; //此处更改b中的nameconsole.log(&apos;更改后的结果如下：&apos;);console.log(&apos;a的内容为：&apos;);console.log(a);console.log(&apos;b的内容为：&apos;);console.log(b); 运行结果如下： 在更改之前，b中的内容完全和a的一样，因为对象是存储在堆内存中的，栈中保存的是地址值，也就是说a实际存储的是这个对象的地址，而不是这个对象内容，所以b = a实际上也只是将a存储的地址给了b，结果就是两个变量a和b实际上是指向了同一块内存空间。 所以当b.name改变的时候，实际上是改变了这块内存空间中name的值，所以在更改之后打印出来的a和b中的name都是’b’，这显然不是我想要的结果，我只是希望更改b中的name为’b’而已，因此在更改b的时候不能干扰到a，所以我需要让b指向另一块内存空间，且拥有与a相同的属性和方法。而深拷贝就是为了决解这种问题。 深拷贝实现的基本思路深拷贝的实现主要依据下面三点： 非引用类型的变量复制的时候，内存会为其分配新的空间。 非引用类型的变量，只需使用 b = a的形式进行复制 如果是引用类型的变量，将其指向的内存空间中的属性与方法拿出来，然后使用上一点的形式进行复制 实现深拷贝的函数方式一具体代码实现如下： 1234567891011function deepCopy(obj){ //如果不是引用类型的变量，直接返回 if(typeof(obj) !== &apos;object&apos;) return obj; //判断是不是数组 let newObj = toString.call(obj) === &apos;[object Array]&apos; ? [] : {}; for(let key in obj){ //因为引用类型的变量之中可以继续存在引用类型的属性，所以此处需要使用递归 newObj[key] = deepCopy(obj[key]); } return newObj;} 测试的代码如下： 12345678910111213141516171819202122232425262728let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;, say:function(){ console.log(&apos;你好&apos;); }, grade:{ Chinese: 100, math: 99, English: 98 }, hobby: [&apos;sing&apos;,&apos;jump&apos;,&apos;rap&apos;,&apos;basketball&apos;]}console.log(&apos;a的内容为：&apos;);console.log(a);let b = deepCopy(a);console.log(&apos;b的内容为：&apos;);console.log(b);b.name = &apos;b&apos;;console.log(&apos;更改后的结果如下：&apos;);console.log(&apos;a的内容为：&apos;);console.log(a);console.log(&apos;b的内容为：&apos;);console.log(b); 测试结果如下： 方式二无意中在网络上看到的另一种比较简单、粗暴的思路，就是将引用类型直接转变为字符串，字符串不是引用类型的变量，因此，可以直接使用b = a的形式进行复制，也能达到我想要的结果。具体代码如下： 12345678function deepCopy(obj){ //如果不是引用类型的变量，直接返回 if(typeof(obj) !== &apos;object&apos;) return obj; //将对象转变为字符串，再进行复制 let newObj = JSON.stringify(obj); //将字符串变回对象 return JSON.parse(newObj);} 测试代码如下： 123456789101112131415161718192021222324252627282930let a = { name: &apos;a&apos;, age: &apos;12&apos;, sex: &apos;man&apos;, say:function(){ console.log(&apos;你好&apos;); }, grade:{ Chinese: 100, math: 99, English: 98 }, hobby: [&apos;sing&apos;,&apos;jump&apos;,&apos;rap&apos;,&apos;basketball&apos;] } console.log(&apos;a的内容为：&apos;); console.log(a); let b = deepCopy(a); console.log(&apos;b的内容为：&apos;); console.log(b); b.name = &apos;b&apos;; console.log(&apos;更改后的结果如下：&apos;); console.log(&apos;a的内容为：&apos;); console.log(a); console.log(&apos;b的内容为：&apos;); console.log(b); 测试结果如下：","link":"/2019/08/10/关于JS深拷贝的思路及函数实现/"},{"title":"vue组件封装-插件式封装","text":"一、插件式的组件封装与一般的是使用插件不同的是，插件式封装的组件会直接在Vue网页运行时直接组件放入页面，根据需要显示或者暂时隐藏起来，并且可以直接调用接口使用，不需要在使用该组件的文件导入该组件，因为会在main.js中使用Vue.use()提前先安装完毕。 二、封装步骤1.封装好需要的组件文件 （1）跟普通组件一样，需要先封装好组件。（2）本次以toast封装为例，因为这个组件比较小，不占用太大的空间；其功能的实现不需要依赖其他组件，便于独立使用。（3）注意的是，需要在该插件中提供一个methods作为外部调用的接口，在toast中，提供了一个 toastShow函数，第一个参数为显示的文本，第二个参数为显示文本的时间，如下： 12345678910methods: { toastShow(message=&apos;默认文字&apos;,delay=1000){ this.message = message; this.isShow = true; setTimeout(()=&gt;{ this.message = &apos;&apos;; this.isShow = false; },delay); }}, （4）说明：在这个组件中，this.isShow和this.message皆为data中的数据，isShow为Boolean，用于确定是否展示toast，message是String，用于确定toast所展示的内容。 2.在该组件的文件夹下建立一个index.js文件文件结构如下： 然后在该文件中做出如下操作 （1）将刚才封装好的toast组件导入。（2）创建一个空对象。（3）调用该对象的isntall函数，需要写一个参数接收Vue。（4）在install函数中，进行如下操作： 调用Vue.extend()函数，以导入的toast组件作为参数，创建一个组件构造器 使用new方式，根据组件构造器创建出一个组件对象 将组件对象挂载到某一个对象上 将组件对象的放入网页中 在Vue的原型上添加$toast，使得在任何文件中都能直接调用该组件 （5）导出该对象（6）具体代码如下： 12345678910111213141516171819202122232425// 导入封装好的组件import Toast from &apos;./Toast&apos;const obj = {};// install函数是在main.js中执行ing的，那莪文件已经导入了Vueobj.install = function(Vue){ // 1.创建组件构造器 const toastContrustor = Vue.extend(Toast); // 2. new的方式，可以根据组件构造器，创建出一个组件对象 const toast = new toastContrustor(); // 3. 将组件对象手动挂载到某一个对象上 toast.$mount(document.createElement(&apos;div&apos;)); // 4. toast.$el对应的就是div document.body.append(toast.$el); // 5. 添加到Vue的原型上 Vue.prototype.$toast = toast;};// 导出export default obj; 3.在main.js文件中挂载（1）在该文件导入toast组件所在文件夹下的index.js文件 1import toast from &apos;components/common/toast&apos; （2）安装 toast 1Vue.use(toast); （3）使用Vue.use()函数的时候，会执行index.js中的代码，会将install函数执行，也就是说，会在页面中创建一个toast，并将toast加入到Vue的原型之中。 三、使用效果1.toast从一开始就被被创建并且存在与页面之中，注意此时为display:none，需要调用toastShow函数才能让其显示出来 2.在需要使用的时候，只需要调用Vue原型中$toast中的methods中的toastShow函数并且传入参数即可；不同于一般的组件需要在使用组件的文件中导入，注册，然后才能使用，只需要一句调用的代码的即可使用该组件，如下1this.$toast.toastShow(&apos;请先选中物品&apos;,500); 3.运行效果","link":"/2019/08/28/vue组件封装-插件式封装/"},{"title":"网络上那些面试题-试题1","text":"题目请写出以下代码的输出结果。 123456789101112131415161718function Foo() { Foo.a = function() { console.log(1) } this.a = function() { console.log(2) }}Foo.prototype.a = function() { console.log(3)}Foo.a = function() { console.log(4)}Foo.a();let obj = new Foo();obj.a();Foo.a(); 答案 4 2 1 分析 1 ~ 8行只是定义了一个函数，并没有执行 9 ~ 11行在这个Foo这个对象的原型上添加了一个a的函数 12 ~ 14行为Foo这个函数添加了一个自定义的方法a，故在调用a时，会在自身中找到。 15行调用了Foo.a()，实际上是调用了12 ~ 14行所添加的a方法，因为函数里定义的Foo.a因为Foo函数此时还没有执行，所以没有生效。 16行new了一个新的Foo的对象obj，同时也执行了Foo函数。因此回到2 ~ 4行，这部分代码为Foo改写了a方法，故以后Foo.a = function(){console.log(1)}；而在4 ~ 7行中，this指向调用Foo的对象obj，故obj.a = function(){console.log(2)}。 17行，此时obj.a = function(){console.log(2)} 18行，此时Foo.a已经被自身函数的代买改写了，故此时Foo.a = function(){console.log(1)}","link":"/2019/08/08/网络上那些面试题-试题1/"},{"title":"网络上那些面试题-试题2","text":"题目用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。答案个人答案： 1234567function reverseOrder(str){ str += &apos;&apos;; if(str.length &lt;= 1) return str; let str1 = reverseOrder(str.slice(0,str.length/2)); let str2 = reverseOrder(str.slice(str.length/2)); return str2+str1;} 这个答案采用的是分治的思想，将一个大问题分解成无数个相同的小问题进行求解，直到无法继续分割(即字符串只剩一个字符为止)，然后按照相反的顺序进行返回，就能得出最终结果。 关于这个问题在网络有许多解法，基本的思路都是将int型数据转成字符串，然后从第一个或最后一个字符开始，每次切割出一个字符，然后按照相反的顺序进行拼接，或者将这个int型数据去除以10求余，然后执行与字符串类似的拼接操作。","link":"/2019/08/09/网络上那些面试题-试题2/"}],"tags":[{"name":"数组操作","slug":"数组操作","link":"/tags/数组操作/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"数据的存储方式","slug":"数据的存储方式","link":"/tags/数据的存储方式/"},{"name":"组件封装","slug":"组件封装","link":"/tags/组件封装/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"算法","slug":"算法","link":"/tags/算法/"}],"categories":[{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}